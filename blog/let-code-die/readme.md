
# Let code die 

"let code die" is a recurring mantra that the [pastagang](https://pastagang.cc) group has picked up and run with

<br>

<hr>

<br>

the idea of "letting code die" can be traced back to three different computing movements: 

- [robust first computing](https://andrewwalpole.com/blog/an-introduction-to-robust-first-computation/)
- [permacomputing](https://permacomputing.net/permacomputing/)
- [local first computing](https://www.inkandswitch.com/local-first/)

i wanted to participate in all three movements at the same time so i tried to figure out what they all have in common. and my idea was that they all acknowledge that code can break and die in various ways, and that we should plan around that.

in my opinion, the three movements don't say that code death is something to be avoided, but rather that it is something to be handled gracefully.

you see, Software is a sort of executable knowledge, and just like unstable particles decaying over time, [knowledge has a half-life too]([url](https://en.wikipedia.org/wiki/Half-life_of_knowledge))!

Should we [kill code with fire](https://www.goodreads.com/en/book/show/54716655-kill-it-with-fire)?

I don't know. is killing it with fire the most graceful thing to do?

<br>

Let's look at what the three movements say: 

- robust first computing
todo
<br>
- permacomputing
todo
<br>
- local first computing

Local first computing proposes a set of principles and ideas for software that resonates with the *let code die* philosophy. It acknowledges that software services and cloud providers will inevitably become inaccessible. Instead of fighting this thought, local first  embraces this nature of software by ensuring that the user's data survives irrespective of any particular service or implementation. When code dies in a local first environment, the data remains alive, ready to be reused with new code. This turns code death into a natural part of the software lifecycle. 

<br>

<hr>

<br>

why do we try to maintain projects that are old and should be deprecated? most such projects have newer alternatives that are more secure, more functional, and better suited for the modern world, yet we keep using things like email, pgp, x11, etc etc

i guess the problem is that we rely on heaps and heaps and stacks and stacks of technology. we can't and probably don't want to get rid of all of it. but where we can and where is reasonable, i think it's nice to not rely on specific pieces of technology. i don't think that's too crazy an idea :)

The pastagang paradox:
Temporary code will live permanently. Code you want to live long and prosper will die young.

## why let code die
- Let code die to have less emotional attachment to code
- and to write more code and then it gets easier
- also to create more room for new different code including all kinds of fun errors.

And
- Let performances die by not recording them.
- Let music die by not recording it.
- Then record anyway to share with people (which kills the music)

## Moving on

If you are grieving or otherwise sensitive to mortality, you can thing of this concept as 'let it float down the river'. Be an observer, take an interest, but don't form unhealthy attachments where they aren't necessary. You can work on this by forming/strengthening healthy attachments with humans using careful trust, self-care and strong boundaries.

# but wait, you're overthinking this, I just am too lazy to keep writing new code all the time.

oh, yes, that happens... well, your code will die anyway at some point. plus exercise is good, repetition is good. repetition is also good and bear in mind that repetition is good too. In moderation. and unmoderation.

<br>

## let this blog post die

i let all the changes I contributed to this blog post die. 


<br>
