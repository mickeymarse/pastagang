let's write a blog post.

i sometimes find that it's helpful to write a throwaway blog post when trying to write something [bigger](https://github.com/pastagang/pastagang/edit/main/paper/readme.md)

<br>

# Let code die 

the origins of "let code die" lie in [robust first computing](https://andrewwalpole.com/blog/an-introduction-to-robust-first-computation/) and [permacomputing](https://permacomputing.net/permacomputing/) and [local first computing](https://www.inkandswitch.com/local-first/). all three movements acknowledge that code can break and die in various ways, and that we should plan around that

why do we try to maintain projects that are old and should be deprecated? most such projects have newer alternatives that are more secure, more functional, and better suited for the modern world, yet we keep using things like email, pgp, x11, etc etc

Software is a sort of executable knowledge, and just like unstable particles decaying over time, [knowledge has a half-life too]([url](https://en.wikipedia.org/wiki/Half-life_of_knowledge))!

**So let's [kill it with fire](https://www.goodreads.com/en/book/show/54716655-kill-it-with-fire)**

# why
- Let code die to have less emotional attachment to code
- and to write more code and then it gets easier
- also to create more room for new different code including all kinds of fun errors.

And
- Let performances die by not recording them. - Let music die by not recording it.
- Then record anyway to share with people (which kills the music)

If you are grieving or otherwise sensitive to mortality, you can thing of this concept as 'let it float down the river'. Be an observer, take an interest, but don't form unhealthy attachments where they aren't necessary. You can work on this by forming/strengthening healthy attachments with humans using careful trust, self-care and strong boundaries.

# but wait, you're overthinking this, I just am too lazy to keep writing new code all the time.

oh, yes, that happens... well, your code will die anyway at some point. plus exercise is good, repetition is good. repetition is also good and bear in mind that repetition is good too. In moderation. and unmoderation.

# let this blog post die

i let all the changes I contributed to this blog post die. 

# how much longer do we even have?

things keep getting worse and worse and worse and there must be some limit, right? a point where things cannot get any worse. but when that limit comes, will there even be anything there? is the worst that things can get simply the absence of all things? everything dies eventually. i can't imagine it getting much worse than that. but maybe it can, and that's where things get confusing. is there a point where to die makes things _better?_ i've met many who would say so, and yet that grates against me. if i keep it alive maybe it can get better. if i keep it alive maybe things will be okay. if i keep it alive...

## but i can't keep it alive, can i?

so should i? is code a person? is letting code die the same as letting a person die? i don't know. i feel like code. i am code, in a way. every interaction with another follows a script. a protocol. i am a machine finding its way through this world. but this machine doesn't even know what it's _for._ should the machine let its own code die? it wouldn't function nearly as well. it would struggle through every interaction and fail at basic tasks. and yet, the code is out of date. and new code can always be written, with lessons learned from the old code. the new code could be better. different. alive in a way the old code cannot be.

### is the code already dead?

maybe improvements aren't to be seen. maybe this machine needs a full wipe, a system clean, to be able to continue in a better way. the machine doesn't die, just the code. and the lessons will always be there.

*maybe i should let the code die*
